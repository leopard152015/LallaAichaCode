/*_________________________________________________________

  This is a standard GP implementation on EASEA, 
  aimed for regression.
  It implements an interval arithmetic check.

  use : easea -gp interval.ez
	make

	OR (if you'd like to exploit a CUDA-compatible graphic card)

	easea -cuda_gp interval.ez
        make

  in order to generate and compile this code.
__________________________________________________________*/

\User declarations :
#include <string.h>
#include <stdlib.h>

#include "interface/CcsvParser.h"
#define csvFile "bac_admis.csv"
std::ifstream fs( csvFile );
CcsvParser parser( fs, ';' );



// these 3 defines are mandatory here. Adjust as you like.
#define NO_FITNESS_CASES 6
#define VAR_LEN 1
#define GROW_FULL_RATIO 0.5

// this is the number of learning cases computed in parallel.
// note that on 1024 is the maximum size on fermi architectures 512 on older cards.
#define NUMTHREAD 1024
#define MAX_STACK 15

#define PI (3.141592653589793)

float input_intervals[] = {2000,2100};
\end

\User functions:
//define POLY(x) x*x*x-3*x*x+x
#define POLY(x) 1/x
/**
   This function generates data NO_FITNESS_CASES fitness cases,
   from the polynome POLY(X) with X randomly picked between (-1,1)

   @inputs address of the inputs array. (array will be allocated here)
   @outputs adddress of the outputs array. (array will be allocated here)

   @ret number of loaded fitness cases (should be equal to NO_FITNESS_CASES).   
 */
int generateData(float*** inputs, float** outputs){
/*  int i=0;

  (*inputs) = new float*[NO_FITNESS_CASES];
  (*outputs) = new float[NO_FITNESS_CASES];
  
  for( i=0 ; i<NO_FITNESS_CASES ; i++ ){
    (*inputs)[i]=new float[VAR_LEN];
    float x = random(-10.,+10.);
    (*inputs)[i][0] = x;
    (*outputs)[i] = POLY(x);
  }

  return NO_FITNESS_CASES;*/
    CcsvData csvData;

    (*inputs) = new float*[NO_FITNESS_CASES];
    (*outputs) = new float[NO_FITNESS_CASES];

     for (unsigned int i = 0; i < NO_FITNESS_CASES; i++){
        (*inputs)[i]=new float[VAR_LEN];
        for (unsigned int j = 0; j < VAR_LEN; j++){
            (*inputs)[i][j] = parser.getCell<float>(i,j);
          printf(" %f ", (*inputs)[i][j]);
        }
        (*outputs)[i] = parser.getCell<float>(i,VAR_LEN);
        printf(" %f \n", (*outputs)[i]);
    }
  return NO_FITNESS_CASES;
}


void free_data(){
  for( int i=0 ; i<NO_FITNESS_CASES ;i++ ) delete[] inputs[i] ;

  delete[] outputs;
  delete[] inputs;
} 

/* INTERVAL ARITHMETIC */

struct interval_t {
	double low;
	double up;
	bool invalid;
};

void get_interval(GPNode *n, interval_t *inter) {
	const unsigned arity = opArity[(int)n->opCode];
	inter->invalid = false;

	if (arity == 0) {
		if (n->opCode == OP_ERC) {
			inter->low = inter->up = n->erc_value;
		} else {
			inter->low = input_intervals[2*n->opCode];
			inter->up = input_intervals[2*n->opCode+1];
		}
	} else if (arity == 2) {
		interval_t int1, int2;
		get_interval(n->children[0], &int1);
		get_interval(n->children[1], &int2);
		double ab, ad, cb, cd;

		switch (n->opCode) {
			case OP_ADD:
				inter->low = int1.low + int2.low;
				inter->up = int1.up + int2.up;
				break;
			case OP_SUB:
				inter->low = int1.low - int2.low;
				inter->up = int1.up - int2.up;
				break;
			case OP_MUL:
				ab = int1.low*int1.up;
				ad = int1.low*int2.up;
				cb = int2.low*int1.up;
				cd = int2.low*int2.low;

				inter->low = min(ab, min(ad, min(cb, cd)));
				inter->up = max(ab, max(ad, max(cb, cd)));
				break;
			case OP_DIV:
				if (int2.low <= 0 && int2.up >= 0) {
					inter->invalid = true;
					break;
				}
				ab = int1.low/int1.up;
				ad = int1.low/int2.up;
				cb = int2.low/int1.up;
				cd = int2.low/int2.low;

				inter->low = min(ab, min(ad, min(cb, cd)));
				inter->up = max(ab, max(ad, max(cb, cd)));
				break;
		}
	}
	return;
}

void check_and_repair(GPNode *n) {
	const unsigned arity = opArity[(int)n->opCode];

	if (arity == 0)
		return;
	if (arity >=1)
		check_and_repair(n->children[0]);
	if (arity >= 2)
		check_and_repair(n->children[1]);

	interval_t inter;
	get_interval(n, &inter);
	if (inter.invalid) {
		OPCODE alt[3] = {OP_ADD, OP_SUB, OP_MUL};
		n->opCode = alt[random(0,2)];
	}
}
\end



\Before everything else function:
{
  generateData(&inputs,&outputs);
}
\end

\After everything else function:
{
  std::cout << toString(((IndividualImpl*)EA->population->Best)->root) << std::endl;

  free_data();
}
\end

\At the beginning of each generation function:
{
  //cout << "At the beginning of each generation function called" << endl;
}		    
\end

\At the end of each generation function:
{		 
  //cout << "At the end of each generation function called" << endl;
}
\end

\At each generation before reduce function:
 //cout << "At each generation before replacement function called" << endl;
\end


\User classes :

GenomeClass {
  GPNode* root;
}
\end

\GenomeClass::display:

\end

\GenomeClass::initialiser :
{
  Genome.root = ramped_hh();
}
\end

\GenomeClass::crossover :
{
  simpleCrossOver(parent1,parent2,child);
  child.valid = false;
}
\end

\GenomeClass::mutator : // Must return the number of mutations
{
  simple_mutator(&Genome);

  //return 1;
}
\end

\begin operator description :
OP_X, "x", 0, {RESULT=INPUT[0];};
OP_ERC, "ERC", 0, {RESULT=ERC;};
OP_ADD, "+", 2, {RESULT=OP1+OP2;};
OP_SUB, "-", 2, {RESULT=OP1-OP2;};
OP_MUL, "*", 2, {RESULT=OP1*OP2;};
OP_SIN, "sin", 1, {RESULT=sinf(OP1);};
OP_COS, "cos", 1, {RESULT=cosf(OP1);};
OP_SQRT, "sqrt", 1, {RESULT=sqrt(OP1);};
OP_DIV, "/", 2, {
  if( !OP2 ) RESULT = 1;
  else RESULT = OP1/OP2;
};



\end


\GenomeClass::evaluator header:
check_and_repair(this->root);
\end

\GenomeClass::evaluator for each fc :
float expected_value = OUTPUT;
ERROR = (expected_value-EVOLVED_VALUE)*(expected_value-EVOLVED_VALUE);
\end

\GenomeClass::evaluator accumulator :
return sqrtf(ERROR);
\end


\User Makefile options: 

CXXFLAGS+=-I/usr/local/cuda/common/inc/ -I/usr/local/cuda/include/
LDFLAGS+=
\end

\Default run parameters :         // Please let the parameters appear in this order
  Number of generations : 50   	// NB_GEN
  Time limit: 0 			// In seconds, 0 to deactivate
  Population size : 5000			//POP_SIZE
  Offspring size : 5000 // 40%
  Mutation probability : 0.1       // MUT_PROB
  Crossover probability : 0.9      // XOVER_PROB
  Evaluator goal : minimise      // Maximise
  Selection operator: Tournament 7
  Surviving parents: 100%//percentage or absolute  
  Surviving offspring: 100%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 7

  Elitism: Strong			//Weak or Strong
  Elite: 1
  Print stats: true				//Default: 1
  Generate csv stats file:false			
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:true				//Default: 0

  //Remote island model: true
  //IP	  file: ip.txt 			//File containing all the remote island's IP
  //Server port : 2929
  //Migration probability: 0.33

  Save population: false
  Start from file:false

  max init tree depth : 4
  min init tree depth : 2

  max tree depth : 8

  size of prog buffer : 200000000
\end
